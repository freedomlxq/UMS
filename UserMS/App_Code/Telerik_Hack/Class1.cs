using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Runtime.Serialization;
using Telerik.Pivot.Core.Groups;
#if NETFX2
using Telerik.Pivot.Legacy;
#endif

namespace Telerik.Pivot.Core
{
    /// <summary>
    /// Used for <see cref="DateTime"/> values to group items, provide well known groups, sort and filter the groups.
    /// </summary>
#if !NETFX2
    [DataContract]
#endif
    public sealed class DateTimeGroupDescription : PropertyGroupDescriptionBase
    {
        private DateTimeStep step;

        static DateTimeGroupDescription()
        {
            DaysCountInMonth = new int[12] { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="DateTimeGroupDescription"/> class.
        /// </summary>
        public DateTimeGroupDescription()
        {
        }

        internal  bool TransformsData
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// Gets or sets the step of the grouping.
        /// Items will be put in an <see cref="IGroup"/> with a <see cref="IGroup.Name"/> based on the <see cref="DateTimeStep"/>.
        /// <seealso cref="DayGroup"/>.
        /// <seealso cref="MonthGroup"/>.
        /// <seealso cref="QuarterGroup"/>.
        /// <seealso cref="YearGroup"/>.
        /// <seealso cref="WeekGroup"/>.
        /// <seealso cref="HourGroup"/> - not auto generated by default.
        /// <seealso cref="MinuteGroup"/> - not auto generated by default.
        /// <seealso cref="SecondGroup"/> - not auto generated by default.
        /// </summary>
#if !NETFX2
        [DataMember]
#endif
        public DateTimeStep Step
        {
            get
            {
                return this.step;
            }

            set
            {
                if (this.step != value)
                {
                    this.step = value;
                    this.OnPropertyChanged("Step");
                }
            }
        }

        private static int[] DaysCountInMonth
        {
            get;
            set;
        }

        private static System.Globalization.Calendar Calendar
        {
            get
            {
                return System.Globalization.CultureInfo.InvariantCulture.Calendar;
            }
        }

        /// <inheritdoc />
        public override string GetUniqueName()
        {
            var uniqueName = string.Format(CultureInfo.InvariantCulture, "{0}.{1}", this.PropertyName, this.Step);
            return uniqueName;
        }

        /// <summary>
        /// Names a group that would contain the <paramref name="item"/>.
        /// <seealso cref="DayGroup"/>.
        /// <seealso cref="MonthGroup"/>.
        /// <seealso cref="QuarterGroup"/>.
        /// <seealso cref="YearGroup"/>.
        /// </summary>
        /// <param name="item">The item to group.</param>
        /// <param name="level">The level of grouping for this <see cref="GroupDescription"/>.</param>
        /// <returns>A name for the group that would contain the <paramref name="item"/>.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "DateTime", Justification = "It is a common type."), System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA2204:Literals should be spelled correctly", MessageId = "DateTimeOffset", Justification = "It is a common type.")]
         protected override object GroupNameFromItem(object item, int level)
        {
            var baseValue = base.GroupNameFromItem(item, level);

            if (baseValue == null)
            {
                return null;
            }
            else if (baseValue is DateTime)
            {
                return this.GetGroupNameForValidDate((DateTime)baseValue);
            }
            else if (baseValue is DateTimeOffset)
            {
                return this.GetGroupNameForValidDate(((DateTimeOffset)baseValue).DateTime);
            }

            throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "Value {0} for Property {1} of item {2} should be DateTime or DateTimeOffset or null.", baseValue, this.PropertyName, item));
        }

        /// <inheritdoc />
         protected override IEnumerable<object> GetAllNames(IEnumerable<object> uniqueNames, IEnumerable<object> parentGroupNames)
        {
            if (parentGroupNames != null)
            {
                // TODO: what if our Start is different than our parent groups? - should not be supported
            }

            IEnumerable<object> result = null;
            YearGroup yearGroup;
            QuarterGroup quarterGroup;
            MonthGroup monthGroup;

            switch (this.Step)
            {
                case DateTimeStep.Year:
                    if (uniqueNames != null)
                    {
                        IEnumerable<YearGroup> yearGroups = Enumerable.OfType<YearGroup>(uniqueNames);
                        if (Enumerable.Any(yearGroups))
                        {
                            int min = int.MaxValue;
                            int max = int.MinValue;

                            foreach (var year in yearGroups)
                            {
                                int y = year.Year;
                                min = Math.Min(min, y);
                                max = Math.Max(max, y);
                            }

                            result = this.YearsInRange(min, max);
                        }
                        else
                        {
                            result = uniqueNames;
                        }
                    }
                    else
                    {
                        result = Enumerable.Empty<object>();
                    }

                    break;

                case DateTimeStep.Quarter:
                    result = DateTimeGroupDescription.QuartersInYear();
                    break;

                case DateTimeStep.Month:
                    if (FirstOrDefault<QuarterGroup>(parentGroupNames, out quarterGroup))
                    {
                        result = DateTimeGroupDescription.MonthsInQuarter(quarterGroup.Quarter);
                    }
                    else
                    {
                        result = DateTimeGroupDescription.MonthsInYear();
                    }

                    break;

                case DateTimeStep.Day:
                    bool isInYear = FirstOrDefault<YearGroup>(parentGroupNames, out yearGroup);
                    bool isInQuarter = FirstOrDefault<QuarterGroup>(parentGroupNames, out quarterGroup);
                    bool isInMonth = FirstOrDefault<MonthGroup>(parentGroupNames, out monthGroup);

                    if (isInMonth)
                    {
                        if (isInYear)
                        {
                            result = this.DaysInMonth(yearGroup.Year, monthGroup.Month);
                        }
                        else
                        {
                            // NOTE: the quarter does not matter since we have more specific range from the month and also quarter does not determine if february is in leap year.
                            result = this.DaysInMonth(monthGroup.Month);
                        }
                    }
                    else if (isInQuarter)
                    {
                        if (isInYear)
                        {
                            result = this.DaysInQuarter(yearGroup.Year, quarterGroup.Quarter);
                        }
                        else
                        {
                            result = this.DaysInQuarter(quarterGroup.Quarter);
                        }
                    }
                    else if (isInYear)
                    {
                        result = this.DaysInYear(yearGroup.Year);
                    }
                    else
                    {
                        result = this.DaysInLeapYear();
                    }

                    break;
            }

            return result;
        }

        /// <inheritdoc />
        protected override Cloneable CreateInstanceCore()
        {
            return new DateTimeGroupDescription();
        }

        /// <inheritdoc />
        protected override void CloneOverride(Cloneable source)
        {
            DateTimeGroupDescription dtgd = source as DateTimeGroupDescription;
            if (dtgd != null)
            {
                this.step = dtgd.step;
            }
        }

        private static IEnumerable<object> MonthsInYear()
        {
            for (int i = 1; i <= 12; i++)
            {
                yield return new MonthGroup(i);
            }
        }

        private static IEnumerable<object> MonthsInQuarter(int quarter)
        {
            for (int month = (quarter * 3) - 2; month <= quarter * 3; month++)
            {
                yield return new MonthGroup(month);
            }
        }

        private static IEnumerable<object> QuartersInYear()
        {
            for (int i = 1; i <= 4; i++)
            {
                yield return new QuarterGroup() { Quarter = i };
            }
        }

        private static bool FirstOrDefault<T>(IEnumerable<object> source, out T value) where T : struct
        {
            if (source != null)
            {
                foreach (var item in source)
                {
                    if (item is T)
                    {
                        value = (T)item;
                        return true;
                    }
                }
            }

            value = default(T);
            return false;
        }

        private IEnumerable<object> YearsInRange(int firstYear, int lastYear)
        {
            for (int year = firstYear; year <= lastYear; year++)
            {
                yield return new YearGroup() { Year = year };
            }
        }

        private IEnumerable<object> DaysInQuarter(int year, int quarter)
        {
            bool isLeapYear = Calendar.IsLeapYear(year);

            return this.DaysInQuarter(isLeapYear, quarter);
        }

        private IEnumerable<object> DaysInQuarter(int quarter)
        {
            return this.DaysInQuarter(true, quarter);
        }

        private IEnumerable<object> DaysInQuarter(bool isLeapYear, int quarter)
        {
            int startMonth = ((quarter - 1) * 3) + 1;
            int endMonth = startMonth + 3;

            for (int month = startMonth; month < endMonth; month++)
            {
                int daysInMonth = DateTimeGroupDescription.DaysCountInMonth[month - 1];
                if (month == 2 && !isLeapYear)
                {
                    daysInMonth = 28;
                }

                for (int day = 1; day <= daysInMonth; day++)
                {
                    yield return new DayGroup(month, day);
                }
            }
        }

        private IEnumerable<object> DaysInLeapYear()
        {
            for (int month = 1; month <= 12; month++)
            {
                int daysInMonth = DateTimeGroupDescription.DaysCountInMonth[month - 1];
                for (int day = 1; day <= daysInMonth; day++)
                {
                    yield return new DayGroup(month, day);
                }
            }
        }

        private IEnumerable<object> DaysInNonLeapYear()
        {
            for (int month = 1; month <= 12; month++)
            {
                int daysInMonth = DateTimeGroupDescription.DaysCountInMonth[month - 1];
                if (month == 2)
                {
                    daysInMonth = 28;
                }

                for (int day = 1; day <= daysInMonth; day++)
                {
                    yield return new DayGroup(month, day);
                }
            }
        }

        private IEnumerable<object> DaysInYear(int year)
        {
            if (Calendar.IsLeapYear(year))
            {
                return this.DaysInLeapYear();
            }
            else
            {
                return this.DaysInNonLeapYear();
            }
        }

        private IEnumerable<object> DaysInMonth(int year, int month)
        {
            if (month == 2 && !Calendar.IsLeapYear(year))
            {
                return this.NonLeapDaysInDebruary();
            }
            else
            {
                return this.DaysInMonth(month);
            }
        }

        private IEnumerable<object> NonLeapDaysInDebruary()
        {
            for (int day = 1; day <= 28; day++)
            {
                yield return new DayGroup(2, day);
            }
        }

        private IEnumerable<object> DaysInMonth(int month)
        {
            int daysInMonth = DateTimeGroupDescription.DaysCountInMonth[month - 1];
            for (int day = 1; day <= daysInMonth; day++)
            {
                yield return new DayGroup(month, day);
            }
        }

        private  object GetGroupNameForValidDate(DateTime date)
        {
            switch (this.Step)
            {
                case DateTimeStep.Year: return new YearGroup(date.Year);
                case DateTimeStep.Quarter: return new QuarterGroup(((date.Month - 1) / 3) + 1);
                case DateTimeStep.Month: return new MonthGroup2(date.Month);
                case DateTimeStep.Week:
                    return new WeekGroup(CultureInfo.InvariantCulture.Calendar.GetWeekOfYear(date, CalendarWeekRule.FirstDay, CultureInfo.InvariantCulture.DateTimeFormat.FirstDayOfWeek));
                case DateTimeStep.Hour:
                    return new HourGroup(date.Hour);
                case DateTimeStep.Minute:
                    return new MinuteGroup(date.Minute);
                case DateTimeStep.Second:
                    return new SecondGroup(date.Second);
                case DateTimeStep.Day:
                default:
                    return new DayGroup(date.Month, date.Day);
            }
        }
    }
}